\documentclass[../NFTComp_IEEE.tex]{subfiles}
\graphicspath{{\subfix{../Images}}}

\begin{document}
\section{Flow Blockchain}
\label{sec:flow_blockchain}
This section goes into detail about the functional aspects of the Flow blockchain and assumes a general knowledge of blockchain technology from the reader and therefore, basic details about blockchain workings are omitted.
\par
\subsection{Consensus Protocol}
Early blockchains implemented \textit{Proof-of-Work (PoW)} as consensus protocol, where nodes solve cryptographic puzzles towards getting the privilege of publishing the next block and getting any rewards included. Before Flow, this protocol fell out of favor due to high levels of energy waste that PoW requires. Computations executed to solve these puzzles have no use whatsoever and the popularity of PoW blockchains such as Bitcoin exacerbated this issue.
\par
The blockchain community reacted by proposing alternative consensus mechanisms, such as reputation based protocols like \textit{Proof-of-Authority (PoA)}, and proportional protocols such as \textit{Proof-of-Elapsed Time (PoET)} or \textit{Proof-of-Stake (PoS)} were proposed as alternatives to PoW \cite{Bouraga2021}.
\par
PoS became a popular alternative in 2020, around the time when Flow was being developed, which also coincided with Ethereum announcing a future fork (The Paris fork scheduled to 2022) to switch its consensus protocol to PoS. As such, Flow was created with a PoS consensus mechanism, joining a growing number of public blockchains using the same type of consensus.

\subsection{Flow Node Roles}
The scalability and throughput claims from Flow derive from an innovative four-node type architecture used to pipeline transaction processing in the network. Flow establishes four node roles, as opposed to the 2-node architecture used by Ethereum, which sacrifices some redundancy and adds a small increase in complexity in return for gains in speed, throughput and scalability, while maintaining minimal operational costs.
\par
The Flow network is based in \textit{consensus nodes} that decide the presence and order of transactions in the blockchain; \textit{collection nodes} used to enhance network connectivity and data availability for applications; \textit{execution nodes} to perform the computations required in transactions; and \textit{verification nodes} to validate outputs returned from the execution nodes \cite{Hentschel2019b}. Delegated computations are validated with \textit{Specialised Proofs of Confidential Knowledge (SPoCK)}, a type of non-interactive zero-knowledge proofs based on the \textit{Boneh-Lynn-Shacham (BLS)} signature scheme developed by Flow creators for this specific purpose \cite{Ben2020}.

\subsection{Cadence Language}
\label{sec:cadence_language}
Cadence is the programming language to write smart contracts in Flow, as well as scripts and transactions required to interact with deployed contracts in the network. Ethereum uses Solidity exclusively to write smart contracts. To interact with a deployed contract in Ethereum, users have to rely in Ethereum's API and interact with it using scripts written in general purpose languages such as Javascript and Python. Flow simplifies this by using Cadence for both smart contract development and to interact with deployed instances in the network. Cadence implements a \textit{Resource Oriented Programming Paradigm} through a strongly static type system, with built in access control mechanics that can be further specialised through a \textit{capability-based} security scheme that can narrow the scope of users allowed to interact with a given resource. Cadence syntax was inspired by modern general-purpose programming languages such as \textit{Swift}, \textit{Kotlin}, and \textit{Rust} \cite{flow2020a} \cite{Cadence2023}.

\subsubsection{Smart Contracts}
\label{sec:smart_contracts}
Smart contracts in Flow serve the same purpose as in Ethereum and other blockchains with similar support. Flow contracts are syntactically different from Solidity, but functionally they are very similar: both use the \textbf{contract} keyword to define the main contract structure, use constructor functions that executed automatically once during deployment and can extend their functionalities by importing external contracts and interfaces. But, unlike Solidity, Cadence does not require the implementation of default destructors because storage management is automatically managed. Smart contracts deployed in Flow remain in an "updatable" phase initially. During it, the code can be updated by the creator(s). Once the developer(s) are satisfied with the contract's performance, they can \textit{lock} it to prevent future changes. This allows for cleaner deploys and optimise blockchain storage, unlike Ethereum that saves any new versions of an existing contract in a new block, which can clutter the blockchain with useless code.

\subsubsection{Interacting with Flow Smart Contracts}
In Flow, if an interaction is limited to read operations, i.e., the script instructions \textbf{do not change} the state of the blockchain, then a \textit{script} should be used. If the instructions do \textbf{change the state} of the blockchain, by saving, modifying or deleting data, a \textit{transaction} needs be used instead. \textit{Transactions} require a valid digital signature and funds allocated to pay for gas costs. Flow restrict modifications to digital objects in storage to only the owner(s) of such object, therefore transactions that do these changes require a digital signature from the owner. \textit{Scripts} on the other hand, are "free" to execute because they do not consume gas, therefore they do not require signatures and are used to read public parameters in a contract.

\subsubsection{Resource Oriented Paradigm}
Cadence establishes its programming paradigm through a special digital object named \textit{Resource} which was inspired by Rust's \textit{linear types}. From a functional point of view, Cadence resources are similar to objects in Object-Oriented programming languages. The difference resides in the control exercised by the language to ensure that Resources are unique in a blockchain environment. Once created, a resource cannot be copied; only moved or destroyed. Since resources cannot be copied, they also can only exist in one location at a time, often saved in an account's storage area. Only functions defined in smart contracts can create resources. Cadence limits the scope of the \textbf{create} keyword used to create an resource to a smart contract. Flow smart contracts are deployed with resource creation functions which then are invoked using transactions, since creating a resource changes the state of the blockchain. So far, resources are exclusive to Flow, which is a limiting factor to establish interoperability with other blockchains.

\subsubsection{Cadence Types}
Cadence was developed as a type-safe language and this is part of the strategy to individualise and uniquely identify each digital object in the blockchain. Cadence uses basic types, similar to Solidity, for basic data elements, such as integers, strings, floats, etc. The nomenclature is slightly different but consistent with Solidity. An unsigned 256 bit integer in Solidity is preceded by \textbf{uint256}, but in Cadence the equivalent type is \textbf{UInt256}. Complex types, e.g, resources, events, structs,etc., have complex types resulting from the concatenation between the name of the implementing contract and the name of the element. Since elements such as resources, structs and events can only be created through a contract that contains their implementation details, Flow uses this to its advantage. Pairing the contract name with the resource name creates a unique identifier by default. This ensures type uniqueness withing a Flow projects since contracts saved in the same account storage require different names. To uniquely identify a specific resource in the blockchain, this nomenclature is extended to include the address of the deployed contract prefixed to this identifier. This strategy can uniquely identify every complex type in the blockchain. For example event emitted by transactions are displayed as \verb|A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn|.
\par
This is a complex type concatenating the address of the deployed contract (0x0ae53cb6e3f42a79), the name of the contract (FlowToken) and the name of the event (TokensWithdrawn).

\subsubsection{Capabilities and References}
\label{sec:cadence_capabilities}
Cadence supports capability-based security through the object-capability model to provide a fine-tune access control mechanism. Similar to traditional capabilities, these are a value that represents the authorisation to access and operate on a digital object.
\par
Capabilities in Cadence divide into \textit{storage} and \textit{account} capabilities depending on the object targeted by it. Capability issuing is limited to the owner of the resource or account targeted and are stored in a special storage \verb|\public| domain area open for public access but restricted to capability storage only. Sec. \ref{sec:cadence_storage_domain} details these concepts thoroughly. After publishing a capability to the \verb|public| domain, another user can "borrow" it. \textit{Borrowing} is an official action in Cadence that retrieves a reference to a stored object using a previously published capability. References in Cadence are akin to memory pointers in general purpose programming languages. Retrieving a reference to a resource returns a pointer of sorts whose functionalities are defined in the borrowed capability. References are used to read data from stored objects without accessing the object directly, thus protecting it against deletion and unauthorised transfers.

\subsubsection{Access Control}
Cadence implements access control in two levels of granularity. At a coarser level, contracts and objects limit the access to their inner constituents, e.g., functions, parameters, structs, etc., using the \textbf{access} keyword, with the scope of access inside parenthesis. \textbf{access(all)} grants public access. \textbf{access(E)}, where \textit{E} is an entitlement restricts access to only users with such entitlement. \textbf{access(account)} limits the scope of access to other functions and objects saved in the same account, while \textbf{access(contract)} narrows the scope to the same type of elements, but limited to the same contract. The most restricted level is \textbf{access(self)}, which restricts access to functions and parameters defined within the element affected.

\paragraph{Entitlements}
Entitlements complement the second level of access by providing granular access control to individual members (fields and functions) of a composite object, namely a resource or a struct. Entitlements can be used to create references to stored resources and structs with different "versions", i.e., the digital object referenced is the same but the sets of fields and functions available are different for each entitlement. Cadence uses \textit{auth(entitlement)} to specify the entitlement to use during the resource retrieval process and '\&' to identify a reference to a resource, while'@' is used to denote the resource itself. For example, consider a \textit{Resource R} with two fields: \textit{access(A) name} and \textit{access(B) age}, where \textit{A} and \textit{B} are custom entitlements defined in the contract where \textit{Resource R} is defined. With a resource \textit{R} in storage, retrieving auth(A) \&R returns a reference to \textit{R} where only \textit{name} is accessible. Conversely, retrieving auth(B) \&R returns a reference to the same resource, but with only \textit{age} available. Entitlements can be combined using 'and' or 'or' logic: \textit{access(A, B) name} sets \textit{name} to require entitlements A \textbf{and} B, while \textit{access(A | B) name} changes the requirement to either entitlement A \textbf{or} B.

\subsection{Token Standards}
Flow standardise its fungible and non-fungible projects by defining contract standards, similarly to Ethereum. Flow developers followed Ethereum's approach in publishing contract standards as interfaces, but they also took the opportunity to name them more suggestively. As such, Flow regulates fungible tokens applications with the \textit{FungibleToken} standard \cite{Dapper2022c}, Ethereum's \textit{ERC-20} equivalent. Non fungible tokens have a corresponding \textit{NonFungibleToken} standard \cite{Dapper2022d} that mirrors Ethereum's \textit{ERC-721} standard. These standards have the same function as in Ethereum, i.e., they guarantee the implementation of parameters and functions defined in the standard, which Flow uses to ensure interoperability within the application ecosystem.

\subsection{Account-based Storage Model}
Flow implements an \textit{Account-centric Storage Model}, different from the \textit{Contract-centric Storage Model} used in Ethereum. Storage locations are indexed from an account address and the amount of storage space per account is proportional to the amount of FLOW token in balance, currently at a rate of 1 FLOW token per 100 MB of storage. An account in Flow is, essentially, a digital object that needs to be saved in the blockchain itself. This requirement establishes that accounts in Flow require a minimum of 0,001 FLOW to be operational, the amount required to sustain the basic structure of an account in the blockchain. This is also the fee to create a new account in Flow, though a newly created account comes with 0.001 FLOW already in its balance. At the time of this writing, FLOW price oscillates between 0.5 and 1\$ per token.

\subsubsection{Storage Domains and Paths}
\label{sec:cadence_storage_domain}
An account in Flow is a digital object identified by an address, contains a \textit{balance} and a set of \textit{public encryption keys} used to validate transactions signed by the account owner. The storage area associated to the account is split into contract storage, where smart contracts are stored, and a general purpose storage area to save other digital objects, such as NFTs and other resources.
\par
The general storage space is divided into three domains: a \verb |\storage| domain only accessible by the account owner and where all data is actually written into; a \verb |\public| domain to store the \textit{capabilities} in Sec. \ref{sec:cadence_capabilities}, therefore limited to read-only access; and a \verb |\private| domain used for capability storage also, but this one restricted to the owner.
\par
Object are stored using UNIX-style paths, with the storage domain as the first element. For example, \verb |\storage\ExampleNFT| indicates an "ExampleNFT" resource stored in the main storage domain, while \verb |\public\ExampleNFTCap| indicates a capability published as "ExampleNFTCap" in the public domain that can be used to retrieve a reference to the ExampleNFT in \verb|\storage|.

\subsubsection{Resource Collections}
\label{sec:resource_collections}
The storage system described in Sec. \ref{sec:cadence_storage_domain} is not flexible if a large number of resources are to be stored. Like UNIX paths, storage paths in Flow need to be unique in each account, which can complicate the storage process as more objects are sent to storage. Flow was developed around the concept of digital collectibles, with the expectation that accounts would hold large numbers of NFTs or other resources. To solve this limitation, Flow uses a special resource called \textit{Collection}. Essentially, a collection is a resource that can save and hold other resources in storage, are standardised in Flow through the \textit{NonFungibleToken} standard and each collection is limited to store resources of one type. Collections needs to be created and saved in a unique storage path, but after that, other resources go in and out of a collection using \textit{deposit} and \textit{withdraw} functions, using token identification numbers to identify the token in question instead of having to create a new and unique storage path for each new resource. In UNIX analogy, collections behave akin to directories.

\end{document}