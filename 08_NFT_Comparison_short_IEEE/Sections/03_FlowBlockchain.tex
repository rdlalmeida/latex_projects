\documentclass[../NFTComp_IEEE.tex]{subfiles}
\graphicspath{{\subfix{../Images}}}

% // TODO: Should Cadence deserves its own section? Or it is OK to be a subsection of Flow?

\begin{document}
\section{Flow Blockchain}
\label{sec:flow_blockchain}
This section goes into detail about the functional aspects of the Flow blockchain and how they differentiate this blockchain from others that support NFTs. This assumes a general knowledge of blockchain technology from the reader and therefore, basic details about blockchain workings are going to be omitted.
\par
\subsection{Consensus Protocol}
The first public blockchains in existence implemented \textit{Proof-of-Work (PoW)} consensus protocol, where nodes solve cryptographic puzzles towards getting the privilege of publishing the next block and getting any rewards that usually follow. In the years that preceded the release of Flow, this protocol fell out of favor among the blockchain universe due to the high levels of energy waste that it entitles. Computations executed in the pursuit of solving these puzzles have no use whatsoever and the popularity of PoW blockchains such as Bitcoin exacerbated this issue.
\par
The blockchain community reacted to this by proposing alternative consensus mechanisms, such as \textit{Proof-of-Authority (PoA)} where the nodes maintain a reputation system in the network and associating the odds of being selected to insert the next block proportional to the reputation value, \textit{Proof-of-Elapsed Time (PoET)}, where the odds of round selection are proportional to the time the node has been waiting for selection, or \textit{Proof-of-Stake (PoS)}, where the probability of a node being selected in a round is proportional to the amount of native cryptocurrency staked, among other less known \cite{Bouraga2021}.
\par
PoS was one of the first alternatives to PoW proposed around the time when Flow was being developed. Also, around that time Ethereum announced a future fork of its chain to switch the consensus protocol to PoS in the new stream. As such, Flow was created and made available from the beginning with a PoS consensus mechanism.

\subsection{Flow Node Roles}
The scalability and efficiency claims of Flow derive from an innovative four-node type architecture used to pipeline executions in the network. The increase in role types, as opposed to the 2-node architecture used by Ethereum, sacrifices some redundancy and adds a small increase in complexity in return for gains in speed, throughput and scalability, while maintaining minimal operational costs.
\par
Flow differentiate its nodes into: \textit{consensus nodes} that decide the presence and order of transactions in the blockchain, \textit{collection nodes} to enhance network connectivity and data availability for applications, \textit{execution nodes} that perform the computations required in transactions, and \textit{verification nodes} to validate the computations returned from the execution nodes \cite{Hentschel2019b}. Delegated computations are validated with \textit{Specialised Proofs of Confidential Knowledge (SPoCK)}, a type of non-interactive zero-knowledge proofs based on the \textit{Boneh-Lynn-Shacham (BLS)} signature scheme. These were developed by the Flow creators for this specific purpose \cite{Ben2020}.

\subsection{Cadence Language}
\label{sec:cadence_language}
Flow's version of Ethereum's Solidity is called Cadence. It is a programming language used to write smart contracts in Flow, as well as the scripts and transactions used to interact with the blockchain and deployed smart contracts. Ethereum uses Solidity only for smart contract development. To interact with the blockchain, i.e., invoke a function, access a public parameter, etc, from a deployed contract, Ethereum API is compatible with several general purpose languages, such as Python and Javascript, for that purpose. Flow integrates all these operations in its own programming language. Cadence implements a \textit{Resource Oriented Programming Paradigm} through a strongly static type system, with built in access control mechanics that can be further specialised, i.e., to narrow the scope of allowed users, through the utilisation of \textit{capability-based} security. Cadence syntax was inspired by modern general-purpose programming languages such as \textit{Swift}, \textit{Kotlin}, and \textit{Rust} \cite{flow2020a} \cite{Cadence2023}. Files written in Cadence, namely smart contracts, transactions and scripts, have the \verb|.cdc| extension. The following sections go into greater detail about the concepts introduced thus far.

\subsubsection{Smart Contracts}
\label{sec:smart_contracts}
Smart contracts in Flow serve the same purpose as in Ethereum and other blockchains with similar support. Syntactically these are quite different from Solidity contracts, but functionally they are very similar: both use the \textbf{contract} keyword to define the main contract structure, define constructor functions that executed automatically once during deployment and can extend their functionalities by importing external contracts and interfaces. They do have differences as well, such as, for example, Cadence does not require the implementation of default destructors in their contracts, unlike Solidity, because Flow blockchain has storage management functionalities that automatically manage blockchain storage when resources or other contracts are deleted/destroyed. Smart contracts deployed in Flow stay initially in an "updatable" phase. During it, the code can be changed in the block storing it. Once the developer(s) are satisfied with the contract's performance, they can \textit{lock} it, thus preventing any future changes. This allows for cleaner deploys and optimise blockchain storage, unlike Ethereum that simply saves any updated versions of a contract in a new block. If the developers do not care to delete the old contract, the blockchain simply keeps these older versions in storage.

\subsubsection{Interacting with Flow Smart Contracts}
Flow differentiates the two types of blockchain interactions with different file types: if an interaction is limited to read operations, i.e., executing the instructions in the file \textbf{does not changes} the state of the Flow blockchain, then a \textit{script} should be used. If the set of instructions to execute \textbf{change the state} of the Flow blockchain (by saving, modifying or deleting data), a \textit{transaction} should be used instead. The main difference between these files is that \textit{transactions} need a valid digital signature to execute and usually require funds to be used as gas as well since Flow, just like Ethereum and others, restrict modifications to digital objects in storage to only the owners of such object, hence it is critical that the owner signs the transactions first. \textit{Scripts} in Flow are "free" to execute, i.e., they do not consume gas, and therefore they do not require any signatures and can be executed by anyone.

\subsubsection{Resource Oriented Paradigm}
Cadence establishes its programming paradigm through a digital object that has a special status among others named \textit{Resource} which was inspired by Rust's \textit{linear types}. From a functional point of view, Cadence Resources are similar to Objects in any Object-Oriented programming language. The main difference resides in the control exercised by the language to ensure that Resources are unique in the blockchain environment. Once created, a resource cannot be copied, only moved or destroyed. Since Resources cannot be copied, they also can only exist in one location at a time, often saved in an account's storage. Resources can only be created through a smart contract function. Cadence uses the \textbf{create} keyword to create an Resource and this keyword can only be used in a smart contract. A smart contract creates a resource by first establishing a function that does creates and returns a given resource, and using a transaction to invoke such function. Creating a Resource changes the state of the blockchain, therefore they requires transactions to execute. Currently only Flow uses this paradigm and it is the main method used to create NFTs. As such, Flow NFTs are not yet compatible with other blockchain due to this fundamental architectural difference.

\subsubsection{Cadence Types}
Cadence was developed as a type-safe language and this is part of the strategy to individualise and uniquely identify each digital object in the blockchain. Cadence uses basic types, similar to Solidity, for basic data elements, such as integers, strings, floats, etc. The nomenclature is slightly different but consistent with Solidity. An unsigned 256 bit integer in Solidity is preceded by \textbf{uint256}, but in Cadence the equivalent type is \textbf{UInt256}. Complex types, e.g, resources, events, structs,etc., have complex types resulting from the concatenation between the name of the implementing contract and the name of the element. Since elements such as resources, structs and events can only be created through a contract that contains their implementation details, Flow uses this to its advantage. Pairing the contract name with the resource name creates a unique identifier by default. This ensures type uniqueness withing a Flow projects since contracts saved in the same account storage require different names. To uniquely identify a specific resource in the blockchain, this nomenclature is extended to include the address of the deployed contract prefixed to this identifier. This strategy can uniquely identify every complex type in the blockchain. For example event emitted by transactions are displayed as \verb|A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn|. This is a complex type concatenating the address of the deployed contract (0x0ae53cb6e3f42a79), the name of the contract (FlowToken) and the name of the event (TokensWithdrawn).

\subsubsection{Access Control}
Cadence implements access control in two levels of granularity. At a coarser level, contracts and objects can limit the access to their inner constituents, e.g., functions, parameters, structs, etc., using the \textbf{access} keyword and the scope of access inside parenthesis after. \textbf{access(all)} grants public access, i.e., anyone can execute a function or access a parameter preceded by this access modifier. \textbf{access(E)}, where \textit{E} is an entitlement restricts access to only users with such entitlement. Entitlements are custom declarations that can be used to fine tune access control in Cadence. For example, a contract can define a function with an \textit{Admin} entitlement level (\textbf{access (Admin)}) restrict its use to only users able to provide the \textit{Admin} entitlement. Moving deeper into Cadence access control, the next level is \textbf{access(account)}. This limits the access of the element to other elements existing within the same account, like for example another smart contract saved in the same account storage. \textbf{Access(contract)} narrows the access further by limiting the element to be accessible only to other elements in the same contract. A function labeled with this modifier can only be invoked by other functions and resources defined in the same contract. The last and most restrictive modifier is \textbf{access(self)} which narrows the scope of access to the element and its children. Elements at the same level in the contract cannot "see it" even. For a more fine grained access control, Cadence has developed a \textit{Capability} system in a similar fashion as other legacy capability based programming languages. Sec. \ref{sec:cadence_capabilities} goes into greater detail about it.

\subsubsection{Capabilities}
\label{sec:cadence_capabilities}

\subsection{Token Standards}

\subsection{Account-based Storage Model}
\subsubsection{Storage Domains and Paths}
\subsubsection{References}
\subsubsection{Resource Collections}

\end{document}