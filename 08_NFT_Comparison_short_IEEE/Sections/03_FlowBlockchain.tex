\documentclass[../NFTComp_IEEE.tex]{subfiles}
\graphicspath{{\subfix{../Images}}}

\begin{document}
\section{Flow Blockchain}
\label{sec:flow_blockchain}
This section goes into detail about the functional aspects of the Flow blockchain and assumes a general knowledge of blockchain technology from the reader and therefore, basic details about blockchain workings are going to be omitted.
\par
\subsection{Consensus Protocol}
The first public blockchains implemented \textit{Proof-of-Work (PoW)} consensus protocol, where nodes solve cryptographic puzzles towards getting the privilege of publishing the next block and getting any rewards that usually follow. In the years that preceded the release of Flow, this protocol fell out of favor due to the high levels of energy waste that it entitles. Computations executed in the pursuit of solving these puzzles have no use whatsoever and the popularity of PoW blockchains such as Bitcoin exacerbated this issue.
\par
The blockchain community reacted to this by proposing alternative consensus mechanisms, such as \textit{Proof-of-Authority (PoA)} where the nodes maintain a reputation system in the network and associating the odds of being selected to insert the next block proportional to the reputation value, \textit{Proof-of-Elapsed Time (PoET)}, where the odds of round selection are proportional to the time the node has been waiting for selection, or \textit{Proof-of-Stake (PoS)}, where the probability of a node being selected in a round is proportional to the amount of native cryptocurrency staked, among other less known \cite{Bouraga2021}.
\par
PoS was one of the first alternatives to PoW proposed around the time when Flow was being developed. Also, around that time Ethereum announced a future fork of its chain to switch the consensus protocol to PoS in the new stream. As such, Flow was created and made available from the beginning with a PoS consensus mechanism.

\subsection{Flow Node Roles}
The scalability and efficiency claims of Flow derive from an innovative four-node type architecture used to pipeline executions in the network. The increase in role types, as opposed to the 2-node architecture used by Ethereum, sacrifices some redundancy and adds a small increase in complexity in return for gains in speed, throughput and scalability, while maintaining minimal operational costs.
\par
Flow differentiate its nodes into: \textit{consensus nodes} that decide the presence and order of transactions in the blockchain, \textit{collection nodes} to enhance network connectivity and data availability for applications, \textit{execution nodes} that perform the computations required in transactions, and \textit{verification nodes} to validate outputs returned from the execution nodes \cite{Hentschel2019b}. Delegated computations are validated with \textit{Specialised Proofs of Confidential Knowledge (SPoCK)}, a type of non-interactive zero-knowledge proofs based on the \textit{Boneh-Lynn-Shacham (BLS)} signature scheme. These were developed by the Flow creators for this specific purpose \cite{Ben2020}.

\subsection{Cadence Language}
\label{sec:cadence_language}
Flow's version of Ethereum's Solidity is Cadence. It is a programming language used to write smart contracts in Flow, as well as the scripts and transactions used to interact with the blockchain and deployed smart contracts. Ethereum uses Solidity only for smart contract development. Interaction with the blockchain, i.e., invoke a function, access a public parameter, etc, from a deployed contract, Ethereum API is compatible with several general purpose languages, such as Python and Javascript, for that purpose. Flow integrates all these operations in its own programming language. Cadence implements a \textit{Resource Oriented Programming Paradigm} through a strongly static type system, with built in access control mechanics that can be further specialised, i.e., to narrow the scope of allowed users, through the utilisation of \textit{capability-based} security. Cadence syntax was inspired by modern general-purpose programming languages such as \textit{Swift}, \textit{Kotlin}, and \textit{Rust} \cite{flow2020a} \cite{Cadence2023}. Files written in Cadence, namely smart contracts, transactions and scripts, have the \verb|.cdc| extension. The following sections go into greater detail about the concepts introduced thus far.

\subsubsection{Smart Contracts}
\label{sec:smart_contracts}
Smart contracts in Flow serve the same purpose as in Ethereum and other blockchains with similar support. Syntactically these are quite different from Solidity contracts, but functionally they are very similar: both use the \textbf{contract} keyword to define the main contract structure, define constructor functions that executed automatically once during deployment and can extend their functionalities by importing external contracts and interfaces. They do have differences as well. For example, unlike Solidity, Cadence does not require the implementation of default destructors in contracts because storage management is automatically managed in Flow when resources or other contracts are deleted/destroyed. Smart contracts deployed in Flow stay initially in an "updatable" phase. During it, the code can be changed in the block storing it. Once the developer(s) are satisfied with the contract's performance, they can \textit{lock} it, thus preventing any future changes. This allows for cleaner deploys and optimise blockchain storage, unlike Ethereum that simply saves any updated versions of a contract in a new block. If the developers do not care to delete the old contract, the blockchain simply keeps these older versions in storage.

\subsubsection{Interacting with Flow Smart Contracts}
Flow differentiates the two types of blockchain interactions with different file types: if an interaction is limited to read operations, i.e., executing the instructions in the file \textbf{does not changes} the state of the Flow blockchain, then a \textit{script} should be used. If the set of instructions to execute \textbf{change the state} of the Flow blockchain (by saving, modifying or deleting data), a \textit{transaction} should be used instead. The main difference between these files is that \textit{transactions} need a valid digital signature to execute and usually require funds to be used as gas as well since Flow, just like Ethereum and others, restrict modifications to digital objects in storage to only the owners of such object, hence it is critical that the owner signs the transactions first. \textit{Scripts} in Flow are "free" to execute, i.e., they do not consume gas, and therefore they do not require signatures to execute. Scripts can be used to read any public parameter in a contract. This can lead to potential privacy issues if a developer does not take sufficient care in protecting sensible data in the contract.

\subsubsection{Resource Oriented Paradigm}
Cadence establishes its programming paradigm through a digital object that has a special status among others named \textit{Resource} which was inspired by Rust's \textit{linear types}. From a functional point of view, Cadence Resources are similar to Objects in any Object-Oriented programming language. The main difference resides in the control exercised by the language to ensure that Resources are unique in the blockchain environment. Once created, a resource cannot be copied, only moved or destroyed. Since Resources cannot be copied, they also can only exist in one location at a time, often saved in an account's storage. Resources can only be created through a smart contract function. Cadence uses the \textbf{create} keyword to create an Resource and this keyword can only be used in a smart contract. A smart contract creates a resource by first establishing a function that does creates and returns a given resource, and using a transaction to invoke such function. Creating a Resource changes the state of the blockchain, therefore it requires transactions to execute. Currently only Flow uses this paradigm and it is the main method to create NFTs. As such, Flow NFTs are not yet compatible with other blockchain due to this fundamental architectural difference.

\subsubsection{Cadence Types}
Cadence was developed as a type-safe language and this is part of the strategy to individualise and uniquely identify each digital object in the blockchain. Cadence uses basic types, similar to Solidity, for basic data elements, such as integers, strings, floats, etc. The nomenclature is slightly different but consistent with Solidity. An unsigned 256 bit integer in Solidity is preceded by \textbf{uint256}, but in Cadence the equivalent type is \textbf{UInt256}. Complex types, e.g, resources, events, structs,etc., have complex types resulting from the concatenation between the name of the implementing contract and the name of the element. Since elements such as resources, structs and events can only be created through a contract that contains their implementation details, Flow uses this to its advantage. Pairing the contract name with the resource name creates a unique identifier by default. This ensures type uniqueness withing a Flow projects since contracts saved in the same account storage require different names. To uniquely identify a specific resource in the blockchain, this nomenclature is extended to include the address of the deployed contract prefixed to this identifier. This strategy can uniquely identify every complex type in the blockchain. For example event emitted by transactions are displayed as \verb|A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn|.
\par
This is a complex type concatenating the address of the deployed contract (0x0ae53cb6e3f42a79), the name of the contract (FlowToken) and the name of the event (TokensWithdrawn).

\subsubsection{Capabilities and References}
\label{sec:cadence_capabilities}
Cadence supports capability-based security through the object-capability model to provide a fine-tune access control mechanism. Similar to traditional capabilities, these are a value that represents the authorisation to access and operate on a digital object.
\par
Capabilities in Cadence divide into \textit{storage} and \textit{account} capabilities depending if the object targeted by it. Capabilities can only be issued by the owner of the resource or account and they get stored in a special account storage area that is open for public access but it can only store capabilities. This is identified as the \textit{public} storage domain. Sec. \ref{sec:cadence_storage_domain} goes into detail about these concepts. After the owner publishes a capability to the public storage domain, another user can "borrow" it. \textit{Borrowing} is an official action in Cadence that retrieves a reference to a stored object through a previously published capability. References in Cadence are akin to memory pointers in some general purpose programming languages. Retrieving a reference to a resource returns a pointer of sorts whose functionalities are defined in the borrowed capability. References are used to access data from stored objects without accessing the object directly, thus protecting it against deletion or unauthorised transfers.

\subsubsection{Access Control}
Cadence implements access control in two levels of granularity. At a coarser level, contracts and objects can limit the access to their inner constituents, e.g., functions, parameters, structs, etc., using the \textbf{access} keyword and the scope of access inside parenthesis after. \textbf{access(all)} grants public access, i.e., anyone can execute a function or access a parameter preceded by this access modifier. \textbf{access(E)}, where \textit{E} is an entitlement restricts access to only users with such entitlement.
\par
Entitlements provide granular access control to individual members (fields and functions) of a composite object, namely a resource or a struct. Entitlements can be used to create the references indicated in Sec. \ref{sec:resource_collections} to stored resources and structs with different "versions", i.e., references to the same digital object but with different sets of fields and functions available. For example, consider a \textit{Resource R} with two fields: \textit{access(A) name} and \textit{access(B) age}, where \textit{A} and \textit{B} are custom entitlements defined in the same contract where \textit{Resource R} is defined. With a \textit{Resource R} created and in storage, retrieving auth(A) \&ResourceR returns a reference to \textit{Resource R} where only \textit{name} is accessible. Conversely, retrieving auth(B) \&ResourceR returns a reference to the same exact resource, but only \textit{age} is available now. Cadence uses \textit{auth(entitlement)} to specify the entitlement to use during the resource retrieval process and '\&' to identify a reference to a resource. When the actual resource is referenced, Cadence uses '@' instead. Entitlements can be combined using 'and' or 'or' logic: \textit{access(A, B) name} sets \textit{name} to require entitlements A \textbf{and} B to be accessible (since '\&', the usual symbol for AND, is already used to denote a reference), while \textit{access(A | B) name} changes the requirements to either entitlement A \textbf{or} B.

\subsection{Token Standards}
Flow standardise its fungible and non-fungible projects by defining contract standards, in similar fashion as Ethereum. Flow developers followed Ethereum's approach in publishing contract standards as interfaces, but these had the opportunity to name them with more suggestive denominations. As such Flow regulates fungible tokens in its contracts with the \textit{FungibleToken} standard \cite{Dapper2022c}, similarly to Ethereum's \textit{ERC-20} standard. Non fungible tokens have a corresponding \textit{NonFungibleToken} standard \cite{Dapper2022d} mirroring closely Ethereum's \textit{ERC-721} standard. Projects implementing these standards, among others, have the same effect as in Ethereum, i.e., they guarantee a set of parameters and functions in the implementing contract, which in Flow are also used to ensure interoperability within Flow's application ecosystem.

\subsection{Account-based Storage Model}
Flow implements an \textit{Account-centric Storage Model}, different from the \textit{Contract-centric Storage Model} used in Ethereum. Storage locations are indexed from an account address and the amount of storage space per account is proportional to the amount of FLOW token in balance currently at a rate of 1 FLOW token per 100 MB of on chain storage. An account in Flow is, its essence, a digital object that needs to be saved in the blockchain itself. This requirement establishes that accounts in Flow require a minimum of 0,001 FLOW to be operational, the amount required to sustain the basic structure of the account in the blockchain. This is also the fee required to create a new account in Flow, though the newly created account is returned with 0.001 FLOW in balance. At the time of this writing, FLOW oscillates between 0.5 and 1\$ per token.

\subsubsection{Storage Domains and Paths}
\label{sec:cadence_storage_domain}
An account in Flow is a digital object identified by an address and contains a \textit{balance} and a set of \textit{public encryption keys} that can be used to validate transactions signed by the account. The storage area associated to the account is split into contract storage, where smart contracts deployed by the account are saved, and a general purpose storage area to save other digital objects, such as NFTs and other resources.
\par
The general storage space is divided into three domains: a \verb |\storage| domain only accessible by the account owner and where all data is actually written into; a \verb |\public| domain used to store the \textit{capabilities} indicated in Sec. \ref{sec:cadence_capabilities}, therefore limited to read-only access; and a \verb |\private| domain used only for capability storage as the previous one, but this one is accessible only to the account owner.
\par
Object are stored using UNIX-style paths, with the storage domain as the first element. For example, \verb |\storage\ExampleNFT| indicates an "ExampleNFT" stored in the main storage domain, while \verb |\public\ExampleNFTCap| indicates a capability published as "ExampleNFTCap" in the public domain that can be used to retrieve a reference to the actual ExampleNFT resource.

\subsubsection{Resource Collections}
\label{sec:resource_collections}
The storage system described in Sec. \ref{sec:cadence_storage_domain} is not very flexible if a large number of resources need to be stored. Like UNIX paths, storage paths in Flow need to be unique in each account, which complicates the storage process as more objects are sent to storage. Flow was developed around the concept of digital collectibles, with the expectation that accounts would hold large numbers of NFTs or other resources. To solve this limitation, Flow uses a special resource called \textit{Collection}. Essentially a collection is a resource used to save and hold other resources in storage. Collections are standardised in Flow through the \textit{NonFungibleToken} standard. For a given resource type, the rule in Flow is to use a collection to store multiple items of the same type. A collection needs to be created and saved in a unique storage path, but after that, other resources go into and out of the collection using \textit{deposit} and \textit{withdraw} functions, using token identification numbers to identify the token in question instead of dealing with a myriad of storage paths. Continuing with the UNIX analogy, collections work similarly to directories in this case.

\end{document}