\documentclass[../NFTComp_IEEE.tex]{subfiles}
\graphicspath{{\subfix{../Images}}}

\begin{document}
\section{Flow Blockchain}
\label{sec:flow_blockchain}
This section goes into detail about the functional aspects of the Flow blockchain. It assumes a general knowledge of blockchain technology from the reader; as such, we omit basic details about blockchain technology.

\subsection{Consensus Protocol}
Early blockchains implemented \textit{Proof-of-Work (PoW)} as a consensus protocol, where nodes solve cryptographic puzzles towards getting the privilege of publishing the next block and getting any rewards included. High levels of electric energy waste with PoW computations made this protocol unpopular. Computations executed to solve these puzzles have no use whatsoever, and the popularity of PoW blockchains such as Bitcoin exacerbated the energy waste issue.
\par
The blockchain community reacted by proposing alternative consensus mechanisms to PoW. Reputation-based protocols, like \textit{Proof-of-Authority (PoA)} and proportional protocols such as \textit{Proof-of-Elapsed Time (PoET)} and \textit{Proof-of-Stake (PoS)}, were among the most popular suggestions \cite{Bouraga2021}.
\par
Dapper Labs developed Flow in 2020, around the time when PoS was becoming a popular alternative. Ethereum also switched to a PoS protocol through the Paris fork, but did so only in 2022. As such, Flow joined a growing number of public blockchains by adopting the PoS consensus protocol as well.

\subsection{Flow Node Roles}
Flow uses an innovative four-node type architecture to pipeline transaction processing in the network, which it claims to provide superior scalability and throughput. This new architecture sacrifices some redundancy and adds a small increase in complexity in return for gains in speed, throughput, and scalability while maintaining minimal operational costs.
\par
The Flow network is based on \textit{consensus nodes} that decide the presence and order of transactions in the blockchain; \textit{collection nodes} used to enhance network connectivity and data availability for applications; \textit{execution nodes} to perform the computations required in transactions; and \textit{verification nodes} to validate outputs returned from the execution nodes \cite{Hentschel2019b}. Delegated computations are validated with \textit{Specialised Proofs of Confidential Knowledge (SPoCK)}, a type of non-interactive zero-knowledge proof. SPoCKs are \textit{Boneh-Lynn-Shacham (BLS)} signature scheme-based proofs created by the founders of Flow \cite{Ben2020}.

\subsection{Cadence Language}
\label{sec:cadence_language}
Cadence is the programming language to write smart contracts in Flow, as well as scripts and transactions required to interact with deployed contracts in the network. Ethereum uses Solidity exclusively to write smart contracts. To interact with a deployed contract in Ethereum, users have to rely on Ethereum's API and interact with it using scripts written in general-purpose languages such as Javascript and Python. Flow simplifies this by using Cadence for both smart contract development and to interact with deployed instances in the network. Cadence implements a \textit{Resource Oriented Programming Paradigm} through a strongly static type system with built-in access control mechanics that can be further specialised through a \textit{capability-based} security scheme that can narrow the scope of users allowed to interact with a given resource. Cadence defines a syntax inspired by modern general-purpose programming languages, such as \textit{Swift}, \textit{Kotlin}, and \textit{Rust} \cite{flow2020a} \cite{Cadence2023}.

\subsubsection{Smart Contracts}
\label{sec:smart_contracts}
Smart contracts in Flow serve the same purpose as in Ethereum and other blockchains with similar support. Flow contracts are syntactically different but functionally similar to Ethereum. Both use the \textbf{contract} keyword to define the main contract structure, use constructor functions that execute automatically once during deployment, and can extend their functionalities by importing external contracts and interfaces.
\par
The similarities stop here. Cadence manages storage automatically, unlike Solidity; therefore, it does not require the implementation of default destructor functions in contracts. Smart contracts deployed in Flow remain in an "updatable" state initially. While in this state, contract owners can update their code. Once the developer(s) are satisfied with the contract's performance, they can \textit{lock} it to prevent future changes, which allows for cleaner deploys and optimises blockchain storage. Ethereum saves any new versions of an existing contract in a new block, which can clutter the blockchain with useless code.

\subsubsection{Interacting with Flow Smart Contracts}
In Flow, if an interaction is limited to read operations, i.e., the script instructions \textbf{do not change} the state of the blockchain, then a \textit{script} should be used. If the instructions do \textbf{change the state} of the blockchain, by saving, modifying, or deleting data, a \textit{transaction} needs to be used instead. \textit{Transactions} require a valid digital signature and funds allocated to pay for gas costs. Transactions that attempt to modify digital objects in storage must have a digital signature from the account owner, since only he/she has access to it. \textit{Scripts} are "free" to execute because they do not consume gas. As such, scripts do not require signatures and are used to read public parameters in a contract.

\subsubsection{Resource Oriented Paradigm}
Cadence establishes its programming paradigm through a special digital object named \textit{Resource}, which was inspired by Rust's \textit{linear types}. From a functional point of view, Cadence resources are similar to objects in object-orientated programming languages. Cadence also establishes the mechanism that guarantees the uniqueness of resources in the network. Once created, a resource can only exist in one location at a time; therefore, it cannot be copied; it can only be moved or destroyed. Only functions defined in smart contracts can create resources. Cadence limits the scope of the \textbf{create} keyword used to create a resource to a smart contract. Creating resources changes the state of the blockchain, which means that resource-creating functions in contracts need a transaction to execute. So far, resources are exclusive to Flow, which is a limiting factor to establishing interoperability with other blockchains.

\subsubsection{Cadence Types}
Cadence uses basic types, similar to Solidity, for elements such as integers, strings, floats, etc. The nomenclature is slightly different than in Solidity. For example, an unsigned 256-bit integer in Solidity is denoted by \textbf{uint256}, while the Cadence equivalent uses \textbf{UInt256}. Complex elements, like resources, events, structs, etc., have complex types that result from concatenating the contract name with the element. Pairing the contract name with the resource name creates a unique identifier by default. This ensures type uniqueness within Flow projects since contracts in the same storage space require different names. To uniquely identify a resource in the blockchain, this nomenclature extends to include the address of the deployed contract as a prefix to the type. \verb|A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn| exemplifies the type of a withdraw event emitted by a FlowToken contract deployed at address 0x0ae53cb6e3f42a79.

\subsubsection{Capabilities and References}
\label{sec:cadence_capabilities}
Cadence provides a fine-tuned access control mechanism through an object-capability model. Capabilities are values that represent the authorisation to access and operate on a digital object. Capabilities in Cadence divide into \textit{storage} and \textit{account} types. Capability issuing is limited to the owner of the resource or account targeted and is stored in a special \verb|\public| domain area available for public access but restricted to store capabilities. Sec. \ref{sec:cadence_storage_domain} provides additional details in these domains. After publishing a capability to the \verb|public| domain, another user can "borrow" it. \textit{Borrowing} in Cadence retrieves a reference to a stored object through a previously published capability. References in Cadence are akin to memory pointers in general-purpose programming languages. Flow uses references to protect stored objects from unauthorised transfers, modifications, and deletions by providing read access to stored objects without allowing access to the object itself.

\subsubsection{Access Control}
Cadence implements access control in two levels of granularity. At a coarser level, contracts and objects limit the access to their inner constituents, e.g., functions, parameters, structs, etc., using the \textbf{access} keyword, with the scope of access inside parenthesis. \textbf{access(all)} grants public access. \textbf{access(E)}, where \textit{E} is an entitlement that restricts access to only users with such entitlement. \textbf{access(account)} limits the scope of access to other functions and objects saved in the same account, while \textbf{access(contract)} narrows the scope to the same type of elements, but limited to the same contract. The most restricted level is \textbf{access(self)}, which restricts access to functions and parameters defined within the element affected.

\paragraph{Entitlements}
Entitlements complement the second level of access by providing granular access control to individual members (fields and functions) of a composite object, namely a resource or a struct. Entitlements are used to create references to stored resources and structs with different "versions." The digital object referenced is the same, but the sets of fields and functions available are different for each entitlement. Cadence uses \textit{auth(entitlement)} to specify the entitlement to use during the resource retrieval process and '\&' to identify a reference to a resource, while '@' is used to denote the resource itself. For example, consider a \textit{Resource R} with two fields: \textit{access(A) name} and \textit{access(B) age}, where \textit{A} and \textit{B} are custom entitlements defined in the contract where \textit{Resource R} is defined. With a resource \textit{R} in storage, retrieving auth(A) \&R returns a reference to \textit{R} where only \textit{name} is accessible. Conversely, retrieving auth(B) \&R returns a reference to the same resource, but with only \textit{age} available. Entitlements can be combined with 'and' or 'or' logic. \textit{access(A, B) name} sets \textit{name} to require entitlements A \textbf{and} B, while \textit{access(A | B) name} changes the requirement to either entitlement A \textbf{or} B.

\subsection{Token Standards}
Flow, like Ethereum, defines standards to standardise fungible and non-fungible token mechanics in smart contracts. Flow developers followed Ethereum's approach in publishing contract standards as interfaces, but they also took the opportunity to name them more suggestively. As such, Flow uses the \textit{FungibleToken} standard \cite{Dapper2022c} to regulate fungible token applications. Ethereum's equivalent standard is \textit{ERC-20}. Non-fungible tokens have a corresponding \textit{NonFungibleToken} standard \cite{Dapper2022d} that mirrors Ethereum's \textit{ERC-721} standard. These standards guarantee the implementation of parameters and functions defined in the standard, which Flow uses to ensure interoperability within the application ecosystem.

\subsection{Account-based Storage Model}
Flow implements an \textit{Account-centric Storage Model}, different from the \textit{Contract-centric Storage Model} used in Ethereum. Storage locations are indexed to an account address instead of a contract address. The amount of storage space available per account is proportional to the account balance in FLOW tokens. The current rate is 1 FLOW token required per 100 MB of storage used. Flow accounts are digital objects stored in the blockchain. This requirement establishes that accounts in Flow require a minimum of 0.001 FLOW to be operational, the amount required to sustain the basic structure of an account in the blockchain. This is also the fee to create a new account in Flow, though a newly created account comes with 0.001 FLOW already in its balance. At the time of this writing, FLOW price oscillates between 0.5 and 1\$ per token.

\subsubsection{Storage Domains and Paths}
\label{sec:cadence_storage_domain}
An account in Flow is a digital object identified by an address, contains a \textit{balance}, and a set of \textit{public encryption keys} used to validate transactions signed by the account owner. The storage area associated with the account is split into contract and general-purpose. Contract storage stores the code from compiled smart contracts, and the general-purpose storage area saves other digital objects, such as NFTs and other resources.
\par
The general storage space is divided into three domains: a \verb|\storage| domain only accessible by the account owner and where all data is actually written into; a \verb|\public| domain to store the \textit{capabilities} referred to in Sec. \ref{sec:cadence_capabilities} limited to read-only access; and a \verb|\private| domain used for capability storage also, but this one restricted to the owner.
\par
Cadence uses UNIX-style paths to store digital objects, using the storage domain as the first element. \verb|\storage\ExampleNFT| indicates an "ExampleNFT" resource stored in the main storage domain, and \verb|\public\ExampleNFTCap| refers to an "ExampleNFTCap" capability published into the public domain.

\subsubsection{Resource Collections}
\label{sec:resource_collections}
The storage system described in Sec. \ref{sec:cadence_storage_domain} is not flexible if a large number of resources are to be stored. Like UNIX paths, storage paths in Flow need to be unique in each account, which complicates the storage process, as more objects are sent to storage. Dapper Labs developed Flow with the concept of digital collectibles in mind. The expectation in this blockchain is that accounts would hold large numbers of NFTs or other resources. To solve this limitation, Flow uses a special resource called \textit{Collection}. Essentially, a collection is a resource that can save and hold other resources in storage, is standardised in Flow through the \textit{NonFungibleToken} standard, and each collection is limited to storing resources of one type. Collections need to be created and saved in a unique storage path, but after that, other resources go in and out of a collection using \textit{deposit} and \textit{withdraw} functions, using token identification numbers to identify the token in question instead of having to create a new and unique storage path for each new resource. Collections in Flow behave akin to directories in UNIX.
\end{document}