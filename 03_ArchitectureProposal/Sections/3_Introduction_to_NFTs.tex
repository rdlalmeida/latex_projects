\documentclass[../3_VotingAndNFTs.tex]{subfiles}
\graphicspath{{\subfix{../../Images}}}

\begin{document}
    \textit{Non-Fungible Tokens (NFTs)} followed cryptocurrencies as another example of digitally unique constructs, which also contribute to the concept of \textit{digital scarcity}, but with functional differences. As implied in the name, NFTs are not fungible, i.e., unlike Bitcoin or Ethereum cryptocurrency tokens, which are interchangeable and can be transacted as fractions of a unit, every NFT is digitally unique and can only be transferred whole. A user can have only a fraction of a Bitcoin in an account (0.56 BTC for example), but the same is not valid for NFTs. Either a user owns it whole, or not. Just as well, users can exchange any cryptocurrency tokens among themselves 
    \par
    The NFT concept is transversal to all blockchains, but since the concept was introduced through the Ethereum chain, the NFT standard is regulated by two \textit{Ethereum Improvement Proposals (EIP)}, namely EIP-721 and EIP-1155. These proposals define a set of base characteristics (variables and functions) that a smart contract needs to implement to conform to the standard. These requirements are abstracted in the respective \textit{Ethereum Request for Comments (ERC)} standards, ERC-721 \cite{ERC721} and ERC-1155 \cite{ERC1155}. It is possible for someone to define an NFT outside of these standards since they are not legally enforceable in any fashion. Yet, since the inception of this concept, the vast majority of published NFts follow this standard since this gives them a level of default interoperability that is hard to achieve otherwise. If a given NFT implements the standards indicated, other users and developers have the guarantee, due to technological requirements that are "forcibly" implemented through the usage of these standards, that the variables and functions defined in the interface are implemented in the NFT contract, similar to what already happens with interfaces in object-oriented programming paradigms.
    \par
    The application potential of this technology regarding digital collectibles has in itself motivated the creation of NFT-centric blockchains, such as Flow \cite{Hentschel2019a}, which were developed towards overcoming aspects that make NFT mechanics too expensive, both in gas spent, resources allocated and execution time, in more general purpose blockchains such as Ethereum for example, as well as online marketplaces dedicated solely to the commercialization of NFTs (e.g., OpenSea \cite{OpenSea2024}) as long as the NFT smart contract implements the standards indicated.
    \par
    Unlike cryptocurrencies, NFTs can store metadata onchain. Yet, because of the high cost associated with writing operations, in most cases, to optimise cost, most of the metadata stored in a NFT is a URL that can be automatically resolved to an off-chain resource, typically an image, a video, or any other type of digital file. This is the most common approach with artistic NFTs and even most digital collectibles \cite{Trautman2022}.

        \subsection{NFTs vs. Cryptocurrencies}
        In a blockchain context, NFTs represent objects, while cryptocurrencies are variables. Though most NFTs produced thus far represent \textbf{digital} objects, there are no strict requirements in that regard. NFTs can easily be used to represent physical object, or more correctly, to establish ownership of that physical object in a digital distributed ledger, but so far the emphasis has been in keeping everything in the digital realm. The amount of cryptocurrency owned by an account is determined by either a balance value stored in the governing contract, which is the case for the majority of ERC-20 (the standard that regulates cryptocurrency contracts in the Ethereum network) tokens, or by determining the Unspent Transactional Output (UTxO) value associated with the account, which is the strategy used by Bitcoin and a few other cases. Adding data to a blockchain using only cryptocurrencies is a challenge in itself, since these do not provide a direct mechanism to write arbitrary data into a block. Before the NFT standard, researchers looking to use a cryptocurrency-based blockchain for alternative applications had to be creative in that regard. One of the more popular approaches is using transactional metadata to add extra data to the transaction that gets written into a block.
        \par
        Bitcoin was extensively explored in this regard, since it was the sole blockchain in operation until Ethereum was introduced in 2015. Bitcoin added new functionalities somewhat periodically, and its $ 0.9.0 $ version introduced the \textit{OP\_RETURN} instruction to its execution set. When run, this instruction always writes its input, unchanged, into the transactional data that gets written into the blockchain \cite{Bartoletti2017}. This provided researchers with an alternative to sending arbitrary data to a blockchain that was not conceived with this functionality in mind.
        \par
        NFTs and smart contracts provide much more efficient and flexible means to achieve the same result. As indicated, NFTs are defined as digital objects, i.e., a pre-defined data structure that can contain several internal parameters, or even other objects if needed. When an NFT gets minted, its metadata is written into a block in the chain. Depending on the actual implementation, this data can be changed afterwards, but typically these operations are restricted to the NFT owner, i.e, changes to the NFT metadata require a digitally signed transaction, which can only be produced by the owner of the account that is currently housing that NFT.
        
        \subsection{NFTs in Contract-based and Account-based blockchains}
        \label{sec:contract-to-account-storage}
        For contract-based blockchains such as Ethereum, NFT metadata is always stored relative to the contract that implements the NFT itself, with information indicating which user "owns" it (typically through an address-to-NFT-identifier mapping). For account-based blockchains such as Flow, NFTs are always and uniquely stored in an account-based location, which can be the minting contract account (address to where the NFT contract was deployed), another contract, or a user account.
        \par
        In a contract-based blockchain, the information of every NFT minted by a contract is always visible in the deployed contract code, i.e., by checking the deployment address of that contract, which leads to the block where the NFT contract is written, it is possible to check the NFT details or metadata for all NFTs minted by that contract, even the ones that were "burned." This means that if the contract gets destroyed, all NFT ownership information is lost permanently. For example, in Ethereum, Solidity contracts can be programmed with a self-destruct function that ensures this result.
            
            \subsubsection{Token Burning}
            Token ownership in a blockchain is abstracted by the ability of a user to access the account containing that token. This essentially consists of the capability of that user to generate a valid digital signature that can sign a transaction to transfer that token to some other location, which implies the user owning or controlling the private encryption key required to generate this signature. Deriving an account address from a private encryption key is a trivial operation, but the opposite is computationally infeasible. The ownership mechanism of a blockchain is implemented based on this asymmetrical relationship.
            \par
            Up to the point of this writing, there is no known private encryption key from which it is possible to derive a \textit{zero address}, i.e., an account address composed solely of zeroes (0x00000...), which implies that no one "controls" that address. No one has the private key that can be used to sign transactions to move tokens out of this address to another location. As such, this address has been used historically to "burn" tokens, which consists of transferring a token (NFT or cryptocurrency) to an unrecoverable address. Once a token goes into the \textit{zero address} account, no one can move it out of it due to the lack of a valid private key that can sign the required transaction. Therefore, "burned" tokens are considered as if they were destroyed, when in reality they are simply stored in an account that no one is able to control \cite{Antonopoulos2018}.

        In account-based blockchains, NFT metadata can be checked by anyone as long as the NFT remains in the minting contract. If the token is moved into an user account, it becomes inaccessible, unless its owner uses the access control features provided by the blockchain to delegate access to that resource. Section \ref{capabilities_references} provided a more detailed explanation on the mechanism used to provide this kind of access control over digital objects. This contract-to-user decoupling also means that destroying the contract does not necessarily mean the destruction of all NFTs minted up to that point. In this particular case, only NFTs still stored in the contract account are destroyed. Tokens already in a user account are safe from destruction.
        \par
        This approach is interesting and has enough application potential to an e-voting system to warrant a more in-depth exploration. The ability of an NFT to store data directly on the chain while simultaneously maintaining close ownership of the digital object used to modulate this data makes NFTs an interesting candidate for an abstraction of digital voting ballots. This article presents a general idea of an NFT-based e-voting system, followed by two specific implementations based on each approach indicated in Section \ref{sec:contract-to-account-storage} regarding the storage of NFT metadata. Both approaches have advantages and disadvantages that can be analysed to determine which paradigm provides an optimal voting system.
\end{document}